/* common */
body {
    color: #333;
    font-weight: 400;
    line-height: 1.4;
    font-size: 16px;
    font-family: 'Nanum Gothic', sans-serif;
}
img{
    display: block;
    /* 인라인 요소이기 때문에 생기는 하단의 공백을 block으로 바꾸어 줌으로써 없앨 수 있다. */
}

a {
    text-decoration: none;
}

.inner {
    width: 1100px;
    margin: 0 auto;
    position: relative;
    /* 위치상의 부모역할을 위해 */
}

.btn {
    width: 130px;
    padding: 10px;
    border: 2px solid #333;
    color: #333;
    border-radius: 4px;
    font-size: 16px;
    /* 부모요소의 영향을 받지않게 끔. */
    font-weight: 700;
    text-align: center;
    cursor: pointer;
    box-sizing: border-box;
    display: block;
    /* 인라인요소에 적용되는 경우에도 정상적으로 작동 할 수 있게 */
    transition: .4s;
}

.btn:hover {
    color: #fff;
    background-color: #333;
}

.btn.btn--reverse {
    background-color: #333;
    color: #fff;
}

.btn.btn--reverse:hover {
    background-color: transparent;
    color: #333;
}
/* 반전된 상태의 버튼을 BEM 표기법을 이용하여 reverse로 명시한다. */

.btn.btn--brown {
    color: #592b18;
    border-color: #592b18;
}

.btn.btn--brown:hover {
    color: #fff;
    background-color: #592b18;
}

.btn.btn--gold {
    color: #d9aa8a;
    border-color: #d9aa8a;
}

.btn.btn--gold:hover {
    color: #fff;
    background-color: #d9aa8a;
}

.btn.btn--white {
    color: #fff;
    border-color: #fff;
}

.btn.btn--white:hover {
    color: #000;
    background-color: #fff;
}
/* 일치선택자로 BEM 표기법으로 작명한 추가함. */
/* 이로써, 버튼의 스타일을 적용하고 하는 곳에 btn 과 btn--색상 클래스를 추가하면 */
/* 위에서 미리 지정한 버튼의 스타일을 사용 할 수 있다. */

/* 자주 재사용되는 내용의 스타일을 common 에 지정하였다. */

.back-to-position {
    opacity: 0;
    transition: 1s;
}

.back-to-position.to-right {
    transform: translateX(-150px);
}

.back-to-position.to-left {
    transform: translateX(150px);
}

.show .back-to-position{
    opacity: 1;
    transform: translateX(0);
}

/* 원래의 위치를 비틀고, scroll magic 라이브러리로 추가된 요소의 자식요소가 될 경우 */
/* 원래의 위치로 돌아오게끔 함으로써 JS 를 사용하지 않고도 애니메이션을 만들어 줄 수 있다. */

.show .back-to-position.delay-0 {
    transition-delay: 0s;
    /* 기본값이지만, 명시적으로 표시한다. */
}

.show .back-to-position.delay-1 {
    transition-delay: .3s;
}

.show .back-to-position.delay-2 {
    transition-delay: .6s;
}

.show .back-to-position.delay-3 {
    transition-delay: .9s;
}
/* 요소마다 CSS transition을 이용해 딜레이를 지정하여 요소가 순차적으로 표시 될 수 있게 한다. */

.swiper-prev,
.swiper-next {
    width: 42px;
    height: 42px;
    border:  2px solid;
    border-radius: 50%;
    position: absolute;

    z-index: 1;
    cursor: pointer;
    outline: none;

    display: flex;
    justify-content: center;
    align-items: center;
    /* 아이콘 중앙 정렬 */

    transition: 0.4s;
}
/* 원래는 promotion 섹션 에서만 사용되던 효과이지만, 다른 영역에서도 사용되므로, */
/* 공통적인 속성들만 전역속성으로 설정한다. */

/* HEADER */

header {
    width: 100%;
    /* fixed와 absolute는 요소의 너비를 최소한으로 쓰려고 함.*/
    /* block(최대)과는 반대되는 특성 */

    /* 그러므로, 빈공간을 축소시키기 때문에, 위처럼 너비를 최대로 주지않으면 */
    /* 빈공간을 없애고 우측에 위치하게된다. */
    background: #f6f5f0;
    border-bottom: 1px solid #c8c8c8;
    position: fixed;
    top: 0;
    /* 요소를 뷰포트 기준으로 배치하기. */
    /* 스크롤을 내려도 fixed, top:0 이기 때문에 아래로 스크롤되지 않는다. */
    z-index: 9;
    /* 헤더에 있는 요소들이 아래에 작성할 다른 요소보다 확실하게 위로 올라 갈 수 있게끔 */
}

header > .inner {
    /* 자식선택자를 사용함으로써, header의 .inner에만 적용된다. */
    /* 이런식으로 자주 사용되는 클래스(common)은 자손보단 자식선택자로 */
    /* 사용하는 편이 재활용하기 편하다. */
    
    /* width: 1100px;
    height: 120px;
    margin: 0 auto;
    position: relative; */
    
    /* 위의 내용은 inner를 공통 css로 지정하고 아래처럼 단축 할 수 있다. */

    height: 120px;
}

header .logo {
    height: 75px;
    position: absolute;
    margin: auto;
    top: 0;
    bottom: 0;
    left: 0;
    /* 스타벅스 로고의 수직 중앙 정렬 */

    /* 정렬기능을 사용 할 수 없는 경우 배치를 이용해서 중앙으로 정렬한다. */
    /* notion 참고하기! */

    /* 여기서 위치 속성들은 해당 요소의 기준이 될 위치를 명시하는 것. */
    /* 요소의 너비를 명시하면, 해당 기준을 토대로 브라우저가 margin을 자동적으로 설정한다. */
    /* margin:auto -> 여백을 공평하게 나눔 */
}


/* 서브 메뉴 스타일 */

header .sub-menu {
    display: flex;
    position: absolute;

    top: 10px;
    right: 0;
}

header .sub-menu ul.menu {
    font-family: arial, sans-serif;
    display: flex;
    /* 내부의 li들을 수평정렬한다. */
}

header .sub-menu ul.menu li {
    position: relative;
    /* 가상요소의 위치상의 부모역할을 위해 relative */
}

header .sub-menu ul.menu li::before {
    /* 서브메뉴 사이의 구분선 만들기 */
    content: "";
    display: block;
    /* position 속성의 display 변환에 의해 생략 될 수 있다. */
    width: 1px;
    height: 12px;
    background: #e5e5e5;

    position: absolute;
    top: 0;
    bottom: 0;
    margin: auto;
    /* 포지션으로 수직 중앙 정렬하기. */
}

header .sub-menu ul.menu li:first-child::before {
    display: none;
    /* 첫번째 li 요소의 가상요소 before를 표시하지 않는다. */
    /* li 가 다수이므로, 생성되는 가상요소도 다수가 된다. */
    /* 그러므로 n번째의 요소의 가상요소를 선택함으로써 원하는 가상요소를 선택 할 수 있다. */
}

header .sub-menu ul.menu li a {
    font-size: 12px;
    padding: 11px 16px;
    display: block;

    color: #656565;
        /* 메뉴를 클릭하기 위해 커서를 올릴 때, 글씨에 올라가야만 클릭이 되는데, */
        /* 위처럼 block으로 변경한 뒤 padding을 사용함으로써 내부의 공간 만큼 */
        /* 클릭 할 수 있는 공간이 늘었다. */

        /* 요런 사소한 디테일이 UX */
}

header .sub-menu ul.menu li a:hover {
    color: #000;
}

header .sub-menu .search {
    height: 34px;

    position: relative;
}

header .sub-menu .search input {
    /* focus 전의 input */
    width: 36px;
    height: 34px;

    padding: 4px 10px;

    border : 1px solid #ccc;
    border-radius: 5px;
    outline: none;
    /* input이 focus 되었을때 나타나는 외곽선을 없앰 */

    box-sizing: border-box;

    background: #fff;
    color: #777;
    
}

header .sub-menu .search input:focus {
    /* 검색창을 클릭했을때 창의 크기 늘리기 */
    width: 190px;
    /* border: 1px solid #669900; */
    border-color: #669900;
    /* 위처럼 컬러만 바꾸고 싶은 경우, 궂이 단축속성을 사용해서 일일히 다쓰지 않고 */
    /* 개별속성을 사용해서 바꾸고자 하는 속성만 바꿔 줄 수 있다. */

    transition: width 0.4s;
}

header .sub-menu .search .material-icons {
    height: 24px;
    /* Material icons 의 기본 높이 */
    
    position: absolute;
    /* absolute이므로, 형제요소들과 겹치게된다. */
    
    top: 0;
    bottom: 0;
    /* 수직 중앙 정렬 */

    right: 5px;
    /* 형제요소가 커질 때, 그 커진 만큼의 너비를 가지게되는데, */
    /* right 속성으로 인해 우측으로 붙어 이동하게 된다. */

    margin: auto 0;

    transition: .4s;
    /* 잊지말자 전환효과는 상위의 것에 작성하기. */
}

header .sub-menu .search.focused .material-icons {
    /* 일치 선택자를 이용하여, search와 focused 가 동시에 지정된 요소의 아이콘을 선택한다. */
    /* (JS 로 제어된 요소임.) */
    opacity: 0;
    /* 일반적으로 사라지기만 하는 경우에 display 를 사용해도 되자만, */
    /* 위의 경우 전환 효과를 사용하기 위해 opacity 를 사용함. */
}


/* 메인 메뉴 스타일 */

header .main-menu {
    display: flex;
    /* 메인메뉴 아이템들을 수평정렬한다. */
    position: absolute;
    bottom: 0;
    right: 0;

    z-index: 1;
    /* 이후에 만들어질 요소들 위에 존재하게 하기 위해서 */
}

header .main-menu .item2 {
    
}

header .main-menu .item .item__name {
    padding: 10px 20px 34px 20px;
    font-family: Arial, sans-serif;
    font-size: 13px;
}

header .main-menu .item:hover .item__name{
    background: #2c2a29;
    color: #669900;
    border-radius: 6px 6px 0 0;
    /* 좌상 우상 우하 좌하 */
}

header .main-menu .item .item__contents {
    width: 100%;
    position: fixed;
    left: 0;
    /* 자신의 위치를 기준점으로, 뷰포트를 기준 100%로 너비를 지정한다. */
    /* 만약 left 위치를 지정하지 않는다면 자신의 위치를 기준으로 늘어나기 때문에 */
    /* 화면전체를 채울 수 없다. */
    display: none;
}

header .main-menu .item:hover .item__contents {
    display: block;
}

/* 각각 item__name, contents 에 :hover 를 붙히지 않는 이유 */

/* 목표 : 마우스가 드롭다운 메뉴에 올라가 있을 때 아이템 메뉴에 hover 효과가 보여야함.*/

/* 1. name에 hover가 붙는 경우 : 결국 contents에 마우스가 올라가지 않고, */
/* item에만 효과가 지정되므로, block을 지정 할 수 없기 때문에 드롭다운 메뉴를 표시할 수 없음. */
/* 2. contents에 hover가 붙는 경우 : 드롭다운 메뉴는 표시되지만, item과는 */
/* 다른 요소이기 때문에 item에 적용되는 배경색 효과가 표시되지 않음. */

/* 즉, 같은 부모요소에 속한 자식요소 두개를 한번에 제어하기 위해서 상위요소인 item에 hover를 지정하는 것. */
/* 이렇게 안하면 JS로 해야함. */
/* 'name에다가 마우스를 올리면 content에 block을 넣어라.' 같이.. 대신, 이렇게 한다해도 드롭다운에 마우스가 있을 때 */
/* name에 hover를 주는 명령이 또 있어야 우리가 원하는 대로 만들 수 있음 */

/* 이렇게 CSS로 처리가 가능한 효과는 왠만하면 다른 언어로 넘겨주지 말자. */

header .main-menu .item .item__contents .contents__menu {
    background: #2c2c29;
}

header .main-menu .item .item__contents .contents__menu > ul{
    display: flex;
    /* inner에 해당하는 ul 요소 */
    padding: 20px 0;
}
/* 여러곳에서 재사용되는 클래스는 자식선택자로! */

header .main-menu .item .item__contents .contents__menu > ul > li{
    width: 220px;
}

header .main-menu .item .item__contents .contents__menu > ul > li h4 {
    padding: 3px 0 12px 0;
    font-size: 14px;
    color: #fff;
}

/* header .main-menu .item .item__contents .contents__menu > ul > li ul {

} */
/* 구조적인 요소로만 사용한 것이며, 사용하지 않으므로 삭제 */

header .main-menu .item .item__contents .contents__menu > ul > li ul li {
    padding: 5px 0;
    font-size: 12px;
    color: #999;
    cursor: pointer;
    /* 마우스가 올라가면 손가락 모양으로 바뀐다. */
    /* 원래라면 각각 링크가 있을 것. */
}

header .main-menu .item .item__contents .contents__menu > ul > li ul li:hover {
    color: #669900;
}

header .main-menu .item .item__contents .contents__texture {
    padding: 26px 0;
    background-image: url("../images/main_menu_pattern.jpg");

    font-size: 12px;
}

/* 아래의 선택자에 inner를 생략하는 이유 */
/* inner에 적용시킬 속성이 없고, h4와 p가 적용될 마지막 depth 이기 때문에 */
/* 자식선택자를 일부러 쓰지 않아도 된다. */

header .main-menu .item .item__contents .contents__texture h4 {
    color: #999;
    font-weight: 700;
}

header .main-menu .item .item__contents .contents__texture p {
    color: #699900;
    margin: 4px 0 14px;
}
/* 패딩이나 마진을 넣을 때는 최소한의 선택자에만 적용한다고 생각합시다. */

/* 다르게 넣을 수 있는 방법은 당연히 존재하지만, 그것이 선택자를 늘리는 거라면 */
/* 최대한 선택자를 늘리지 않고, 명령어 줄을 늘리지 않고 같은 모양을 만들어 낼 수 있는 */
/* 코드를 작성하는 것이 최적화나 가독성에 있어서 더 유리하니까. */

header .badges {
    position: absolute;
    top: 120px;
    right: 12px;

}

header .badges .badge {

}

header .badges .badge img{
    margin-top: 12px;
    border-radius: 10px;
    box-shadow: 4px 4px 10px rgba(0,0,0,.15);
    cursor: pointer;
}
/* 위의 내용은 위의 badge에 적용하는 방법도 있는데, */
/* 내용은 위와 동일하게 하되, overflow:hidden 을 추가하면된다. */

/* css의 뎁스가 깊어지지 않는 것이 좋아서 그런건가 싶다. */
/* 일단 내가 생각한 내용도 출력은 같으니 그냥 내비두기. */


/* VISUAL SECTION*/

.visual {
    margin-top: 120px;
    background-image: url(../images/visual_bg.jpg);
    background-position: center;
}

.visual .inner{
    height: 646px;
    /* 내부에 있는 요소들의 전체 높이를 묶게 됨(=wrapper) */

    /* common에서 이미 position 값이 지정되어 있으므로 생략한다. */
}

.visual .title{
    position: absolute;
    top: 88px;
    left: -10px;
}

.visual .title .btn{  
    /* position: relative; top: 36px; left: 170px; */
    position: absolute; 
    top: 259px; 
    left: 173px;
}

.visual .cup1.image{
    position: absolute;
    bottom: 0;
    right: -47px;
}

.visual .cup1.text{
    position: absolute;
    right: 170Px;
    top: 39px;
}

.visual .cup2.image{
    position: absolute;
    right: 165px;
    bottom: 0;
}

.visual .cup2.text{
    position: absolute;
    bottom: 226px;
    left: 428px;
}

.visual .spoon{
    position: absolute;
    bottom: 0;
    left: 277px;
}

.visual .fade-in {
    opacity: 0;
}


/* NOTICE */

.notice {
    
}

.notice .notice-line {
    position: relative;
}

.notice .notice-line .bg-left {
    position: absolute;
    top: 0;
    left: 0;
    width: 50%;
    height: 100%;
    background: #333;
}

.notice .notice-line .bg-right {
    position: absolute;
    top: 0;
    right: 0;
    width: 50%;
    height: 100%;
    background: #f6f5ef;
}
/* 각각 50%씩의 너비를 가지고, 100%의 높이를 가진다.(inner의 높이)*/
/* 여기서 position 속성으로 각각의 요소가 좌우 끝에 배치되게끔 함으로써  */
/* 화면너비의 반반을 가지는 모양이 된다. */

.notice .notice-line .inner {
    height: 62px;
    display: flex;
}
/* 위의 좌우 요소들은 높이가 없지만, 같은 형제요소인 inner가 부모요소의 컨텐츠 높이가 되므로,  */
/* inner에서 지정한 높이를 가진다. */  

/* inner를 잘 사용함으로써 요소 각각에 설정을 하는 것이 아니라 하나의 요소로 다른 요소를 함께 */
/* 제어할 수 있는 구조를 만드는 것이 좋다. */

.notice .notice-line .inner .inner__left {
    width: 60%;
    /* 공지사항 요소의 배경은 유지하고, inner 안의 요소들을 제어하여 원하는 가로의 너비를 지정한다. */
    /* 두 요소를 flex로 지정하여, 좌측에 너비를 60%로 지정하여 원하는 비율로 만든다. */
    /* 즉, 큰 배경위에 작은 배경이 겹쳐져있다고 보면 될 거 같다. */
    /* 검사도구 올려보셈 */

    height: 100%;
    background: #333;
    display: flex;
    align-items: center;
}


.notice .notice-line .inner .inner__left h2 {
    color: #fff;
    font-size: 17px;
    font-weight: 700;
    margin-right: 20px;
}

.notice .notice-line .inner .inner__left .swiper {
    height: 62px;
    flex-grow: 1;
    /* flex-grow 로 함께 속한 요소의 너비를 제외한 나머지 부분을 채운다. */
}

.notice .notice-line .inner .inner__left .swiper .swiper-slide{
    height: 62px;
    display: flex;
    align-items: center;
    /* 글씨를 수직 정렬함. */
}

.notice .notice-line .inner .inner__left .swiper .swiper-slide a{
    color: #fff;
    
}

.notice .notice-line .inner .inner__left .notice-line__more {
    width: 62px;
    height: 62px;
    display: flex;
    justify-content: center;
    align-items: center;
    /* flex는 align-content 없다. */
    /* 헷갈리지 말기. */
}

.notice .notice-line .inner .inner__left .notice-line__more .material-icons {
    color: #fff;
    font-size: 30px;
    /* 아이콘이 a 태그에 속해있으므로, a태그의 기본색상인 파란색으로 표시된다. */
    /* 이때 글씨의 색상을 바꾸어 색을 변경 할 수 있다. */
}

.notice .notice-line .inner .inner__right {
    width: 40%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    /* flex-end로 요소를 우측 끝으로 위치시킨다. */
}

.notice .notice-line .inner .inner__right h2 {
    font-size: 17px;
    font-weight: 700;
}

.notice .notice-line .inner .inner__right .toggle-promotion {
    width: 62px;
    height: 62px;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
}

.notice .notice-line .inner .inner__right .material-icons {
    font-size: 30px;
}

.notice .promotion {
    height: 693px;
    background: #f6f5ef;
    position: relative;
    transition: height 0.4s;
    overflow: hidden;
    /* overflow 가 hide 에 지정되어 있을 경우, 숨겨질 때는 잘 작동하지만, */
    /* 나타날 때는 해당 속성이 사라지면서 내부의 이미지가 바로 노출된다. */
}

.notice .promotion.hide {
    height: 0;
    /* 숨겨야 한다고 display : none 을 작성한다면, 자연스러운 전환효과가 일어나지 않는다. */
    /* 높이를 0으로 만들고, 전환효과를 줌으로써 닫히고 열리는 효과를 주는 것. */
}

.notice .promotion .swiper {
    width: calc(819px * 3 + 20px);
    height: 553px;
    position: absolute;
    top: 40px;
    left: 50%;
    margin-left: calc((819px * 3 + 20px) / -2);
    /* margin-left : -1238.5px */
    /* calc() 을 이용하여, 위에서 이미 계산된 요소의 너비의 절반을 마진의 음수값으로 지정한다. */

    /* 어떠한 요소를 가운데 정렬하기 위해 위치의 기준을 중앙(left 50%)으로 */
    /* 정렬하고, 요소의 너비 절반 만큼을 이동시킨다. */
    /* position 의 left 50%와 margin-left 를 함께 사용하며, 위의 방법이 자주쓰인다. */
    /* 반대로 right를 기준으로도 할 수 있다. */
}

.notice .promotion .swiper-slide{
    opacity: 0.5;
    transition: opacity 1s;
    position: relative;
}

.notice .promotion .swiper-slide-active{
    opacity: 1;
}
/* 위의 swiper-slide-active는 swiper 라이브러리가 활성화된 요소에 부여하는 클래스로, */
/* 활성화된 요소를 개발자도구로 확인하여 확인 할 수 있다. */

.notice .promotion .swiper-slide .btn{
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    margin: 0 auto;
}

.notice .promotion .swiper-pagination {
    position: absolute;
    bottom: 40px;
    left: 0;
    right: 0;

    z-index: 0;
    /* pagination 의 인디케이터가 기본적으로 z-index를 11로 가지고 있으므로, */
    /* 위의 값을 추가하여 header에 가려질 수 있게끔 한다. */
}

/* .notice .promotion .swiper-pagination-bullet {
    background-image: url(../images/promotion_slide_pager.png);
    background-color: transparent;
    width: 12px;
    height: 12px;
    margin: 0 3px;
    outline: none;
}

.notice .promotion .swiper-pagination-bullet-active {
    background: url(../images/promotion_slide_pager_on.png);
}  */
/* 개발자 도구를 통해 pagination 으로 적용된 인디케이터의  */
/* 클래스를 찾아 속성을 변경 시켜줌으로써, 내가 원하는 인디케이터의 */
/* 모양으로 수정 할 수 있다. */

/* 라이브러리를 사용하면서, 어떤 클래스가 사용되는지 분석할 수 있다면, */
/* 이를 이용하여 내가 원하는 스타일등을 지정해 줄 수 있다. */

.notice .promotion .swiper-pagination-bullet {
    width: 12px;
    height: 12px;
    margin: 0 3px;
    background: #ddd;
    opacity: 1;
}

.notice .promotion .swiper-pagination-bullet-active {
    box-sizing: border-box;
    background-color: transparent;
    border: 3px solid green;
}
/* 위의 강의 예제와는 다르게, 이미지 파일을 쓰지 않고 CSS로만 만든 인디케이터 */


.notice .promotion .swiper-prev,
.notice .promotion .swiper-next {
    border-color: #333;
    color: #333;
    top: 300px;
}
/* 같은 내용의 스타일을 다수의 선택자에 적용하고 싶을 때는 위처럼 다중 선택자를 이용하는 방법이있다. */
/* 이 때 주의할 점은 아무리 짧은 선택자라도 쉼표 후에는 줄바꿈을 한 뒤에 함께할 선택자를 작성한다. */
/* 이는 가시성을 위함. */

/* award 섹션에서도 버튼이 사용되므로, 위에 있던 내용은 전역 속성으로 일부 옮겨가고 */
/* 차이가 있는 내용만 여기 남겨둠. */




.notice .promotion .swiper-prev {
    left: 50%;
    margin-left: -480px;
}

.notice .promotion .swiper-next {
    right: 50%;
    margin-right: -480px;
}

.notice .promotion .swiper-prev:hover,
.notice .promotion .swiper-next:hover {
    color: #fff;
    background-color: #333;
}

/* 두 요소 모두 해당 버튼이 가운데에 위치하게 하기 위해서 50%로 위치를 지정하고, */
/* 마진을 이용하여 그 위치를 조절했다. */

/* 위의 480px은 계산해서 나온것은 아니고, 직접 위치를 확인해 보고 적당한 값을 선택한 것. */

/* REWARDS */
.rewards {
    position: relative;
}

.rewards .bg-left {
    width: 50%;
    height: 100%;
    background: #272727;
    position: absolute;
    /* relative 일 경우 부모요소에 컨텐츠가 없으므로, 해당 요소 높이가 0으로 지정된다. */
    /* absolute 일 경우, 아래에서 inner로 인해 지정된 부모요소의 크기를 받아 100%가 부모요소의 높이가 된다. */
    top: 0;
    left: 0;
}

.rewards .bg-right {
    width: 50%;
    height: 100%;
    background: #d5c798;
    position: absolute;
    top: 0;
    right: 0;
}

.rewards .inner {
    background-image: url(../images/rewards.jpg);
    height: 241px;
}

.rewards .btn-group {
    position: absolute;
    right: 0;
    bottom: 60px;
    width: 250px;
    display: flex;
    flex-wrap: wrap;
}

.rewards .btn-group .btn.sign-up {
    margin-right: 10px;
}

.rewards .btn-group .btn.sign-in {
    width: 110px;
}

.rewards .btn-group .btn.gift {
    width: 250px;
    /* flex-grow : 1; 로 대체가능 */
    /* 오히려 px을 계산하지 않고, 자동적으로 늘어나게끔 할 수 있다. */
    margin-top: 10px;
}

.youtube {
    position: relative;
    height: 700px;
    /* 영상의 크기와는 별개로, 해당 섹션의 높이만을 지정한다. */
    background-color: #333;
    overflow: hidden;
    /* 넘친 영상을 자른다. */
}

.youtube .youtube__area {
    position: absolute;
    width: 1920px;
    left: 50%;
    margin-left: -960px;
    /* margin-left : calc(1920px /-2) 로 계산함수를 이용 할 수 있음 */

    /* 오른쪽으로 밀었다가 왼쪽을 당겨오기 */
    /* 크기가 변경되더라도 중앙을 유지한다. */

    top: 50%;
    margin-top: calc(1920px * 9 / 16 /-2);
    /* 좌우 중앙을 맞춘 것 처럼 상하 중앙을 맞춰준다. */
    /* 이로써 우리가 원하는 영역에 영상의 중앙이 재생된다. */
    background-color: orange;
}

.youtube .youtube__area::before {
    content: "";
    /* 잊지말자 content */
    display: block;
    /* 이렇게 추가된 가상요소 선택자는 inline 요소이므로 block 으로 바꾸어 주어야 */
    /* 높이를 가질 수 있다. */
    /* content 에 내용이 없으므로. */
    width: 100%;
    height: 0;
    padding-top: 56.25%;
}
/* 단순히 스타일만을 위해서 요소를 추가해야한다면, HTML 파일에 구조를 추가하는 것 보다는 */
/* CSS 의 가상요소 선택자로 처리하는 것이 좋다. */

/* !!!!구조는 최대한 간결하게, 언어는 용도에 맞게!!!! */

.youtube #player {
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0;
}
/* YT iframe API 를 이용해서 영상을 불러와도 player에 크기가 없다면 영상을 표시할 수 없다. */

.youtube .youtube__cover {
    background-image: url(../images/video_cover_pattern.png);
    background-color: rgba(0,0,0,0.3);
    /* rgba로 배경색을 넣는 이유 */

    /* 위의 내용이 없어도 정상적으로 배경이미지의 패턴이 위에 그려지지만, */
    /* 투명도를 준 배경색으로 해당 구역을 전체적으로 어둡게 하는 용도로 사용함. */

    position: absolute;
    /* 문서의 순서상 뒤에 있지만, 위의 형제요소들이 position 속성을 가지므로, */
    /* z-index에서 하위 순서임. */
    /* absolute 를 줌으로써, 문서 순서에 의해 상단으로 올라온다. */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* 부모의 영역 전부를 덮어야하므로, 각각 100%를 지정한다. */
}
/* 출력될 유튜브 영상의 '위'에 한겹을 더 씌우는(cover) 요소의 스타일. */
/* 위의 요소가 존재함으로써 영상을 사용자가 클릭 할 수 없게끔한다. */
/* 위의 내용이 none으로 처리된다면, 아래의 영상을 클릭하고, 일시정지 할 수 있게된다. */

.youtube .inner {
        height: 700px;
    }

.youtube .inner .floating{

}

.youtube .inner .floating1{
    position: absolute;
    top: 50px;
    left: 0;
}

.youtube .inner .floating2 {
    position: absolute;
    bottom: 120px;
    left: 150px;
}



/* SEASON PRODUCT */

.season-product {
    background-image: url(../images/season_product_bg.jpg);

}

.season-product .inner {
    height: 400px;
}

.season-product .inner .floating3{
    position: absolute;
    right: 0;
    top: -200px;
}

.season-product .text-group {
    position: absolute;
    top: 110px;
    right: 100px;
}

.season-product .text-group .title {

}

.season-product .text-group .description {
    margin-top: 10px;
}

.season-product .text-group .more {
    margin-top: 15px;
}


/* RESERVE COFFEE */

.reserve-coffee {
    background-image: url(../images/reserve_bg.jpg);
}

.reserve-coffee .inner {
    height: 400px;
}

.reserve-coffee .reserve-logo {
    position: absolute;
    top: 110px;
    left: 0;
}

.reserve-coffee .text-group {
    position: absolute;
    top: 124px;
    left: 208px;
}

.reserve-coffee .product {
    position: absolute;
    top: 0;
    right: 0;
}

/* season product 섹션과 reserve coffe 섹션은 정렬을 사용하지 않고 배치를 사용한다. */
/* display flex 를 이용한 수평 정렬이 아니라, position absolute 를 이용해서 배치함. */

/* PICK YOUR FAVORITE */

.pick-your-favorite {
    background-image: url(../images/favorite_bg.jpg);
    background-position: center;
    background-attachment: fixed;
    background-size: cover;


}

.pick-your-favorite .inner {
    /* height: 700px;
    display: flex;
    align-items: center; */

    padding: 110px 0;

    /* 위처럼 flex를 이용해서 중앙정렬을 하는 방법도 있지만, */
    /* padding 을 이용하여 중앙정렬을 하는 방법도 사용 할 수 있다. */

    /* 이 경우 내부의 컨텐츠 크기가 변경될 때 추가적인 수정없이 자동으로 높이가 지정된다. */
}

.pick-your-favorite .text-group {
    display: flex;
    width: 362px;
    flex-wrap: wrap;
    justify-content: flex-end;
    margin-left: 100px;

    /* 수평정렬을 flex end 로 지정해 이미지를 우측정렬하는 속성*/
    /* flex로 지정한 요소가 수평으로 쌓이는데, 이 때 가로의 너비를 제한함으로써  */
    /* 요소들이 가로의 너비에 맞춰 wrap 된다. */

    /* 또 한 flex 의 방향이 row 인 경우, flex end 는 우측에 위치하므로, 각각의 요소들이 우측 정렬된다. */
    /* 만약 flex 방향이 column 인 경우, flex end 는 하단이 되므로, 원하는 모양으로 정렬 할 수 없다.*/
}

.pick-your-favorite .text-group .title {
    margin-bottom: 40px;
}

.pick-your-favorite .text-group .description {
    /* margin:40px 0; */

    margin-bottom: 40px;
}

/* RESERVE STORE */

.reserve-store {
    background-image: url(../images/reserve_store_bg.jpg);
    background-attachment: fixed;
    background-repeat: no-repeat;
    background-size: cover;
    background-position: center;
    /* 배경 위치 fixed 를 이용한 패럴렉스 구현 */
}

.reserve-store .inner {
    height: 600px;
    display: flex;
    justify-content: center;
    align-items: center;
    /* 이미지의 가운데 정렬 */
}

.reserve-store .medal {
    width: 334px;
    height: 334px;
    /* 이미지의 크기에 맞춰서 요소의 크기를 결정함 */
    /* block 요소가 최대의 너비를 가지려고 하기 때문에, 이미지가 아닌 옆공간에 hover 하여도 */
    /* 속성이 실행되기 때문에 이미지의 크기에 맞춰 크기를 조절한다. */
    perspective: 600px;
    /* 3d 변환 효과 중에 원근감을 위한 속성 */
}

.reserve-store .medal .front,
.reserve-store .medal .back {
    width: 334px;
    height: 334px;
    position: absolute;
    backface-visibility: hidden;
    /* 애니메이션으로 인해 회전하였을 때, 뒷 면을 숨김. */
    transition: 1s;
}

.reserve-store .medal .front {
    transform: rotateY(0deg);
    /* 명시적 작성 */
}

.reserve-store .medal:hover .front {
    transform: rotateY(180deg);
}

.reserve-store .medal .back {
    transform: rotateY(-180deg);
}

.reserve-store .medal:hover .back {
    transform: rotateY(0deg);
}

/* medal 에 hover를 설정하는 이유는 해당 요소가 hover가 될 때, */
/* 자식으로 속한 모든 요소가 제어돼야 하기 때문. */
/* 위의 메뉴 리스트를 만들때도 같은 개념으로 작성했음. */

.reserve-store .medal .back .btn {
    position: absolute;
    width: 130px;

    bottom: 50px;
    left: 0;
    right: 0;
    margin: 0 auto;
    /* 크기와 포지션 0, 마진을 이용한 중앙 배치방법. */
}

.find-store {
    background-image: url(../images/find_store_bg.jpg);
}

.find-store .inner {
    height: 400px;
}

.find-store .texture1 {
    position: absolute;
    top: 0;
    left: 400px;
}

.find-store .texture2 {
    position: absolute;
    bottom: 0;
    right: 0;
}

.find-store .picture {
    border-radius: 50%;
    box-shadow: 2px 2px 8px rgba(0,0,0,.5);
    position: absolute;
    /* 아래의 두 요소의 position 값이 동일하므로, 공통되는 선택자에  */
    /* 적용하여도 아래의 모양에는 변화가 없다. */
}

.find-store .picture1 {
    left: 20px;
    top: -60px;
}

.find-store .picture2 {
    bottom: 40px;
    left: 270px;
}

.find-store .text-group {
    width: 200px;
    position: absolute;
    /* flex 쓸 필요 없이 그냥 마진만 줘도 ㅇㅋ */

    bottom: 80px;
    right: 350px;
}

.find-store .text-group .title {
    margin-bottom: 20px;
}

.find-store .text-group .description{
    margin-bottom: 20px;
}

/* AWARDS */

.awards {
    background-color: #272727;
}

.awards .inner {
    padding: 40px 0;
}

.awards .swiper {
    width: 100%;
    height: 40px;
}

.awards .swiper-wrapper {

}

.awards .swiper-slide {

}

.awards .swiper-prev,
.awards .swiper-next {
    border-color: white;
    color: #fff;
    top: 0;
    bottom: 0;
    margin: auto;
    opacity: .3;
    /* 기본적인 스타일은 상단의 전역속성으로 지정함. */
    /* 추가적으로 색상과 위치, 투명도만 조절함. */
}

.awards .swiper-prev {
    left: -100px;
}

.awards .swiper-next {
    right: -100px;
}   

.awards .swiper-prev:hover,
.awards .swiper-next:hover {
    background-color: #fff;
    color: #333;
}

/* FOOTER */
footer {
    background-color: #272727;
    border-top: 1px solid #333;
}

footer .inner{
    padding-top: 40px;
    padding-bottom: 60px;
}

footer .menu {
    display: flex;
    justify-content: center;
}

footer .menu li{
    position: relative;
}

footer .menu li::before{
    content: "";
    width: 3px;
    height: 3px;
    background-color: #555;
    position: absolute;
    top: 0;
    bottom: 0;
    right: -1px;
    margin: auto;
}

footer .menu li:last-child::before{
    display: none;
}

footer .menu li a{
    display: block; 
    /* a태그는 인라인! 클릭 할 수 있는 공간을 확보하기 위해 블록처리 후 패딩을 준다. */
    /* 또한 인라인 요소였기 때문에 제대로 상하 여백이 작동하지 않았던 부분을 자연스럽게 처리 할 수 있다. */
    /* 미리 작성해봤던 것 처럼 높이를 준다거나, aling-items center 를 준다거나. */
    padding: 15px;
    font-size: 12px;
    color: #fff;
}

footer .menu li a.green{
    color: #669900;
    /* 모든 a태그가 li에 속한 첫번째 요소 이므로 first-child 로는 효과를 줄 수 없다.*/
    /* 대신 아래에 주석 처리된 선택자를 사용해서 첫번째 a에 효과를 줄 수 있다. */
    /* 근데 위처럼 보기가 직관적인게 좋은건가, 아니면 클래스를 줄이는게 중요한가는 고민해봐야겠다. */
}

/* footer .menu li:first-child a{
    color: #669900;
} */

footer .btns {
    display: flex;
    justify-content: center;

    margin-top: 20px;
}

footer .btns .btn{
    font-size: 13px;
    margin-right: 10px;
}

footer .btns .btn:last-child{
    margin-right: 0;
}
/* 마지막 버튼에 마진이 존재하는 경우 중앙이 약간 어긋나기 때문에,  */
/* 필요없는 마진을 초기화한다. */

footer .info {
    margin-top: 30px;
    text-align: center;
}

footer .info span {
    font-size: 12px;
    margin-right: 20px;
    color: #999;
}
/* 인라인이니까 flex 가 필요없음. */

footer .info span:last-child {
    margin-right: 0;
}  
/* 필요없는 마진 초기화 */

footer .copyright {
    color: #999;
    text-align: center;
    margin-top: 12px;
    font-size: 12px;
}

footer .logo {
    margin: 30px auto 0;
    /* 잊지말자 상 좌우 하 */
    /* 잊지말자 무조건 mt 부터 시작 */
}

#to-top {
    width: 42px;
    height: 42px;
    background-color: #333;
    color: #fff;
    border: 2px solid #fff;
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 9;
}